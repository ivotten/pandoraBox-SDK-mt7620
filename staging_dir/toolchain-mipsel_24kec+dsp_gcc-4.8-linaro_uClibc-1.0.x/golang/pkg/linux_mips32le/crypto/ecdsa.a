!<arch>
__.PKGDEF       0           0     0     644     19587     `
go object linux mips32le go1.4.2 X:precisestack

$$
package ecdsa
	import crypto "crypto"
	import runtime "runtime"
	import io "io"
	import elliptic "crypto/elliptic"
	import asn1 "encoding/asn1"
	import big "math/big"
	type @"math/big".Word uintptr
	type @"math/big".divisor struct { @"math/big".bbb @"math/big".nat; @"math/big".nbits int; @"math/big".ndigits int }
	import rand "math/rand" // indirect
	type @"math/rand".Source interface { Int63() (? int64); Seed(@"math/rand".seed int64) }
	type @"math/rand".Rand struct { @"math/rand".src @"math/rand".Source }
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) ExpFloat64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Float32 () (? float32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Float64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int () (? int)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int31 () (? int32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int31n (@"math/rand".nÂ·3 int32) (? int32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int63 () (? int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int63n (@"math/rand".nÂ·3 int64) (? int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Intn (@"math/rand".nÂ·3 int) (? int)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) NormFloat64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Perm (@"math/rand".nÂ·3 int) (? []int)
	func (@"math/rand".rÂ·1 *@"math/rand".Rand) Seed (@"math/rand".seedÂ·2 int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Uint32 () (? uint32)
	type @"io".RuneScanner interface { ReadRune() (@"io".r rune, @"io".size int, @"io".err error); UnreadRune() (? error) }
	type @"math/big".nat []@"math/big".Word
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".add (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".and (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".yÂ·4 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".andNot (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".yÂ·4 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x0") @"math/big".bit (@"math/big".iÂ·3 uint) (? uint) { var @"math/big".jÂ·4 int; ; @"math/big".jÂ·4 = int(@"math/big".iÂ·3 / 0x20); if @"math/big".jÂ·4 >= len(@"math/big".zÂ·2) { return 0x0 }; return uint(@"math/big".zÂ·2[@"math/big".jÂ·4] >> (@"math/big".iÂ·3 % 0x20) & @"math/big".Word(0x1)) }
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".bitLen () (? int)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x0") @"math/big".bytes (@"math/big".bufÂ·3 []byte "esc:0x0") (@"math/big".iÂ·1 int)
	func (@"math/big".zÂ·1 @"math/big".nat "esc:0x0") @"math/big".clear ()
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".cmp (@"math/big".yÂ·3 @"math/big".nat "esc:0x0") (@"math/big".rÂ·1 int)
	func (@"math/big".qÂ·1 @"math/big".nat) @"math/big".convertWords (@"math/big".sÂ·2 []byte "esc:0x0", @"math/big".charsetÂ·3 string "esc:0x0", @"math/big".bÂ·4 @"math/big".Word, @"math/big".ndigitsÂ·5 int, @"math/big".bbÂ·6 @"math/big".Word, @"math/big".tableÂ·7 []@"math/big".divisor "esc:0x0")
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".decimalString () (? string)
	func (@"math/big".zÂ·3 @"math/big".nat) @"math/big".div (@"math/big".z2Â·4 @"math/big".nat, @"math/big".uÂ·5 @"math/big".nat, @"math/big".vÂ·6 @"math/big".nat) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".nat)
	func (@"math/big".zÂ·3 @"math/big".nat "esc:0x2") @"math/big".divLarge (@"math/big".uÂ·4 @"math/big".nat, @"math/big".uInÂ·5 @"math/big".nat, @"math/big".vÂ·6 @"math/big".nat) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".nat)
	func (@"math/big".zÂ·3 @"math/big".nat) @"math/big".divW (@"math/big".xÂ·4 @"math/big".nat, @"math/big".yÂ·5 @"math/big".Word) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".Word)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expNN (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat "esc:0x0", @"math/big".mÂ·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expNNWindowed (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat "esc:0x0", @"math/big".mÂ·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expWW (@"math/big".xÂ·3 @"math/big".Word, @"math/big".yÂ·4 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".make (@"math/big".nÂ·3 int) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat) @"math/big".modW (@"math/big".dÂ·3 @"math/big".Word) (@"math/big".rÂ·1 @"math/big".Word)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mul (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mulAddWW (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".Word, @"math/big".rÂ·5 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mulRange (@"math/big".aÂ·3 uint64, @"math/big".bÂ·4 uint64) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".norm () (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".or (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".yÂ·4 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	func (@"math/big".nÂ·2 @"math/big".nat) @"math/big".probablyPrime (@"math/big".repsÂ·3 int) (? bool)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".random (@"math/big".randÂ·3 *@"math/rand".Rand, @"math/big".limitÂ·4 @"math/big".nat "esc:0x0", @"math/big".nÂ·5 int) (? @"math/big".nat)
	func (@"math/big".zÂ·4 @"math/big".nat) @"math/big".scan (@"math/big".rÂ·5 @"io".RuneScanner, @"math/big".baseÂ·6 int) (? @"math/big".nat, ? int, ? error)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".set (@"math/big".xÂ·3 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".setBit (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".iÂ·4 uint, @"math/big".bÂ·5 uint) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".setBytes (@"math/big".bufÂ·3 []byte "esc:0x0") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".setUint64 (@"math/big".xÂ·3 uint64) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".setWord (@"math/big".xÂ·3 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".shl (@"math/big".xÂ·3 @"math/big".nat, @"math/big".sÂ·4 uint) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".shr (@"math/big".xÂ·3 @"math/big".nat, @"math/big".sÂ·4 uint) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".string (@"math/big".charsetÂ·3 string "esc:0x0") (? string)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".sub (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".trailingZeroBits () (? uint)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".xor (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".yÂ·4 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	import fmt "fmt" // indirect
	type @"fmt".State interface { Flag(@"fmt".c int) (? bool); Precision() (@"fmt".prec int, @"fmt".ok bool); Width() (@"fmt".wid int, @"fmt".ok bool); Write(@"fmt".b []byte) (@"fmt".ret int, @"fmt".err error) }
	type @"fmt".ScanState interface { Read(@"fmt".buf []byte) (@"fmt".n int, @"fmt".err error); ReadRune() (@"fmt".r rune, @"fmt".size int, @"fmt".err error); SkipSpace(); Token(@"fmt".skipSpace bool, @"fmt".f func(? rune) (? bool)) (@"fmt".token []byte, @"fmt".err error); UnreadRune() (? error); Width() (@"fmt".wid int, @"fmt".ok bool) }
	type @"math/big".Int struct { @"math/big".neg bool; @"math/big".abs @"math/big".nat }
	func (@"math/big".zÂ·2 *@"math/big".Int) Abs (@"math/big".xÂ·3 *@"math/big".Int "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Add (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) And (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) AndNot (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Binomial (@"math/big".nÂ·3 int64, @"math/big".kÂ·4 int64) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int) Bit (@"math/big".iÂ·3 int) (? uint)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") BitLen () (? int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x1") Bits () (? []@"math/big".Word) { return @"math/big".xÂ·2.@"math/big".abs }
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Bytes () (? []byte)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Cmp (@"math/big".yÂ·3 *@"math/big".Int "esc:0x0") (@"math/big".rÂ·1 int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Div (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int) DivMod (@"math/big".xÂ·4 *@"math/big".Int, @"math/big".yÂ·5 *@"math/big".Int, @"math/big".mÂ·6 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Exp (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int "esc:0x0", @"math/big".mÂ·5 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".xÂ·1 *@"math/big".Int "esc:0x0") Format (@"math/big".sÂ·2 @"fmt".State, @"math/big".chÂ·3 rune)
	func (@"math/big".zÂ·2 *@"math/big".Int) GCD (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int, @"math/big".aÂ·5 *@"math/big".Int, @"math/big".bÂ·6 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) GobDecode (@"math/big".bufÂ·3 []byte "esc:0x0") (? error)
	func (@"math/big".xÂ·3 *@"math/big".Int "esc:0x0") GobEncode () (? []byte, ? error)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Int64 () (? int64)
	func (@"math/big".zÂ·2 *@"math/big".Int) Lsh (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".nÂ·4 uint) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int "esc:0x0") MarshalJSON () (? []byte, ? error)
	func (@"math/big".zÂ·3 *@"math/big".Int "esc:0x0") MarshalText () (@"math/big".textÂ·1 []byte, @"math/big".errÂ·2 error)
	func (@"math/big".zÂ·2 *@"math/big".Int) Mod (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) ModInverse (@"math/big".gÂ·3 *@"math/big".Int, @"math/big".nÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Mul (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) MulRange (@"math/big".aÂ·3 int64, @"math/big".bÂ·4 int64) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Neg (@"math/big".xÂ·3 *@"math/big".Int "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Not (@"math/big".xÂ·3 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Or (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int) ProbablyPrime (@"math/big".nÂ·3 int) (? bool)
	func (@"math/big".zÂ·2 *@"math/big".Int) Quo (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int) QuoRem (@"math/big".xÂ·4 *@"math/big".Int, @"math/big".yÂ·5 *@"math/big".Int, @"math/big".rÂ·6 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Rand (@"math/big".rndÂ·3 *@"math/rand".Rand, @"math/big".nÂ·4 *@"math/big".Int "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Rem (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Rsh (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".nÂ·4 uint) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Scan (@"math/big".sÂ·3 @"fmt".ScanState, @"math/big".chÂ·4 rune) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int) Set (@"math/big".xÂ·3 *@"math/big".Int "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) SetBit (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".iÂ·4 int, @"math/big".bÂ·5 uint) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x2") SetBits (@"math/big".absÂ·3 []@"math/big".Word) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) SetBytes (@"math/big".bufÂ·3 []byte "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) SetInt64 (@"math/big".xÂ·3 int64) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int) SetString (@"math/big".sÂ·4 string, @"math/big".baseÂ·5 int) (? *@"math/big".Int, ? bool)
	func (@"math/big".zÂ·2 *@"math/big".Int) SetUint64 (@"math/big".xÂ·3 uint64) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Sign () (? int) { if len(@"math/big".xÂ·2.@"math/big".abs) == 0x0 { return 0x0 }; if @"math/big".xÂ·2.@"math/big".neg { return -0x1 }; return 0x1 }
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") String () (? string)
	func (@"math/big".zÂ·2 *@"math/big".Int) Sub (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Uint64 () (? uint64)
	func (@"math/big".zÂ·2 *@"math/big".Int) UnmarshalJSON (@"math/big".textÂ·3 []byte) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int) UnmarshalText (@"math/big".textÂ·3 []byte) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int) Xor (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) @"math/big".binaryGCD (@"math/big".aÂ·3 *@"math/big".Int, @"math/big".bÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·4 *@"math/big".Int) @"math/big".scan (@"math/big".rÂ·5 @"io".RuneScanner, @"math/big".baseÂ·6 int) (? *@"math/big".Int, ? int, ? error)
	type @"crypto/elliptic".CurveParams struct { P *@"math/big".Int; N *@"math/big".Int; B *@"math/big".Int; Gx *@"math/big".Int; Gy *@"math/big".Int; BitSize int }
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) Add (@"crypto/elliptic".x1Â·4 *@"math/big".Int, @"crypto/elliptic".y1Â·5 *@"math/big".Int, @"crypto/elliptic".x2Â·6 *@"math/big".Int, @"crypto/elliptic".y2Â·7 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) Double (@"crypto/elliptic".x1Â·4 *@"math/big".Int, @"crypto/elliptic".y1Â·5 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·2 *@"crypto/elliptic".CurveParams) IsOnCurve (@"crypto/elliptic".xÂ·3 *@"math/big".Int, @"crypto/elliptic".yÂ·4 *@"math/big".Int) (? bool)
	func (@"crypto/elliptic".curveÂ·2 *@"crypto/elliptic".CurveParams "esc:0x2") Params () (? *@"crypto/elliptic".CurveParams) { return @"crypto/elliptic".curveÂ·2 }
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) ScalarBaseMult (@"crypto/elliptic".kÂ·4 []byte "esc:0x0") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) ScalarMult (@"crypto/elliptic".BxÂ·4 *@"math/big".Int, @"crypto/elliptic".ByÂ·5 *@"math/big".Int, @"crypto/elliptic".kÂ·6 []byte "esc:0x0") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·4 *@"crypto/elliptic".CurveParams) @"crypto/elliptic".addJacobian (@"crypto/elliptic".x1Â·5 *@"math/big".Int, @"crypto/elliptic".y1Â·6 *@"math/big".Int, @"crypto/elliptic".z1Â·7 *@"math/big".Int, @"crypto/elliptic".x2Â·8 *@"math/big".Int, @"crypto/elliptic".y2Â·9 *@"math/big".Int, @"crypto/elliptic".z2Â·10 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) @"crypto/elliptic".affineFromJacobian (@"crypto/elliptic".xÂ·4 *@"math/big".Int, @"crypto/elliptic".yÂ·5 *@"math/big".Int, @"crypto/elliptic".zÂ·6 *@"math/big".Int) (@"crypto/elliptic".xOutÂ·1 *@"math/big".Int, @"crypto/elliptic".yOutÂ·2 *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·4 *@"crypto/elliptic".CurveParams) @"crypto/elliptic".doubleJacobian (@"crypto/elliptic".xÂ·5 *@"math/big".Int, @"crypto/elliptic".yÂ·6 *@"math/big".Int, @"crypto/elliptic".zÂ·7 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	type @"crypto/elliptic".Curve interface { Add(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".x2 *@"math/big".Int, @"crypto/elliptic".y2 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); Double(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); IsOnCurve(@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) (? bool); Params() (? *@"crypto/elliptic".CurveParams); ScalarBaseMult(@"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); ScalarMult(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) }
	type @"".PublicKey struct { ? @"crypto/elliptic".Curve; X *@"math/big".Int; Y *@"math/big".Int }
	type @"crypto".PublicKey interface {}
	type @"io".Reader interface { Read(@"io".p []byte) (@"io".n int, @"io".err error) }
	import hash "hash" // indirect
	type @"hash".Hash interface { BlockSize() (? int); Reset(); Size() (? int); Sum(@"hash".b []byte) (? []byte); Write(@"io".p []byte) (@"io".n int, @"io".err error) }
	type @"crypto".Hash uint
	func (@"crypto".hÂ·2 @"crypto".Hash) Available () (? bool) { return @"crypto".hÂ·2 < @"crypto".Hash(0xE) && @"crypto".hashes[@"crypto".hÂ·2] != nil }
	func (@"crypto".hÂ·2 @"crypto".Hash) HashFunc () (? @"crypto".Hash) { return @"crypto".hÂ·2 }
	func (@"crypto".hÂ·2 @"crypto".Hash) New () (? @"hash".Hash)
	func (@"crypto".hÂ·2 @"crypto".Hash) Size () (? int)
	type @"crypto".SignerOpts interface { HashFunc() (? @"crypto".Hash) }
	type @"".PrivateKey struct { ? @"".PublicKey; D *@"math/big".Int }
	func (@"".privÂ·2 *@"".PrivateKey "esc:0x2") Public () (? @"crypto".PublicKey) { return &@"".privÂ·2.PublicKey }
	func (@"".privÂ·3 *@"".PrivateKey) Sign (@"".randÂ·4 @"io".Reader, @"".msgÂ·5 []byte "esc:0x0", @"".optsÂ·6 @"crypto".SignerOpts "esc:0x0") (? []byte, ? error)
	func @"".GenerateKey (@"".cÂ·3 @"crypto/elliptic".Curve, @"".randÂ·4 @"io".Reader) (@"".privÂ·1 *@"".PrivateKey, @"".errÂ·2 error)
	func @"".Sign (@"".randÂ·4 @"io".Reader, @"".privÂ·5 *@"".PrivateKey, @"".hashÂ·6 []byte "esc:0x0") (@"".rÂ·1 *@"math/big".Int, @"".sÂ·2 *@"math/big".Int, @"".errÂ·3 error)
	func @"".Verify (@"".pubÂ·2 *@"".PublicKey, @"".hashÂ·3 []byte "esc:0x0", @"".rÂ·4 *@"math/big".Int, @"".sÂ·5 *@"math/big".Int) (? bool)
	func @"".init ()
	var @"crypto".hashes []func() (? @"hash".Hash)

$$
 _go_.v          0           0     0     644     86296     `
go object linux mips32le go1.4.2 X:precisestack

!
  go13ldcrypto.a"crypto/elliptic.aencoding/asn1.aio.amath/big.a ş."".(*PrivateKey).Public     Â  <  ¥$+@¢  %          £ `       ¬ £¯  <  !$ ¡¯ à    €€¨Ê„€€…x ."".(*PrivateKey).Public   0€€€À 0runtime.morestack_noctxt   h€€ˆÂ„€€x $type.*"".PublicKey     "".~r0 *type.crypto.PublicKey "".priv  &type.*"".PrivateKey   
R
  TgclocalsÂ·a08e9001cb8f9d822225de3b8e406515 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f   Œ/home/lintel/PandoraBox-MT7620/build_dir/toolchain-mipsel_24kec+dsp_gcc-4.8-linaro_uClibc-1.0.x/golang-1.4.2/src/crypto/ecdsa/ecdsa.goş*"".(*PrivateKey).Sign  €  € Â  <  ¥$+@¢  %         Äÿ½'  ¿¯D ¡ ¡¯H ¡`  ¯ ¡¯@ ¡d  ¯ ¡¯L ¡h  ¯ ¡¯P ¡l  ¯ ¡¯T ¡p  ¯ ¡¯       ( ¦ ¥0 ¦¯$ £  ¤
 `, £¯`  ¯d  ¯h  ¯l £¯% p ¦¯  ¿ à< ½'4  ¯8  ¯4 ¥¯8 ¤¯  <  !$ ¡¯4 ¡' ¡¯        ¡'  !$ ¢'  #Œ $Œ  C¬ D¬        £ §% ` §¯p £¯ ¦ ¤d ¦¯ ¥l ¤¯h ¥¯  ¿ à< ½'    €€¨Ê„€€…x *"".(*PrivateKey).Sign   0€€€À 0runtime.morestack_noctxt   Ø€€€À "".Sign   ˆ€€ˆÂ„€€x ,type."".ecdsaSignature   °€€€À runtime.convT2E   ø€€€À *encoding/asn1.Marshal   hp  "".autotmp_0004 ,type."".ecdsaSignature "".err type.error "".~r4 Xtype.error "".~r3 @type.[]uint8 "".opts 0,type.crypto.SignerOpts "".msg type.[]uint8 "".rand type.io.Reader "".priv  &type.*"".PrivateKey 
	xG P >b
	#   TgclocalsÂ·df47e04495aeec9ad0763bc648c6b4e3 TgclocalsÂ·1c5b1c90a4c2549bb9ca6a7854f35d0e   Œ/home/lintel/PandoraBox-MT7620/build_dir/toolchain-mipsel_24kec+dsp_gcc-4.8-linaro_uClibc-1.0.x/golang-1.4.2/src/crypto/ecdsa/ecdsa.goş&"".randFieldElement  Ğ  Ğ Â  <  ¥$+@¢  %         Ìÿ½'  ¿¯L  ¯P  ¯H  ¯8 ¡' "Œ ¢¯  !Œ  !Œ	ø       £$ £¯ bŒÃ B !" Ã  "$  <  !$ ¡¯Ã/  ¢¯ ¥¯Ã' % %  ¢¯ ¤¯        ¡'  %Œ "Œ $Œ% ( ¥¯ ¥¯, ¤¯ ¤¯@ ¡0 ¢¯ ¡¯D ¡ ¢¯ ¡¯%          ¡ £P ¡¯%  `L £¯  ¿ à4 ½'  <  !$ ¡¯       ( ¡ £ ¡¯, ¡ ¡¯0 ¡ £¯ ¡¯        £  <  !$H £¯ ¡¯        £$ ¡ £¯ "Œ  <  9'  ! ¢¯ ¡¯       H ¤ £ ¤¯ ¤¯%  £¯       H £  <  9'  ! £¯ £¯ ¡¯         ¿ à4 ½'     €€¨Ê„€€…x &"".randFieldElement   0€€€À 0runtime.morestack_noctxt          à€€ˆÂ„€€x type.[]uint8   ¸€€€À "runtime.makeslice   È€€€À io.ReadFull    €€ˆÂ„€€x "type.math/big.Int   ¸€€€À "runtime.newobject   ˆ€€€À 0math/big.(*Int).SetBytes    €€ˆÂ„€€x "type.math/big.Int   À€€€À "runtime.newobject   ğ€€Èó„€€™x "".one   ˜€€€À &math/big.(*Int).Sub   Ø€€€À &math/big.(*Int).Mod   ğ€€Èó„€€™x "".one    €€€À &math/big.(*Int).Add   8`  "".autotmp_0011  type.int "".autotmp_0010  $type.*math/big.Int "".autotmp_0009  $type.*math/big.Int "".b type.[]uint8 "".params Btype.*crypto/elliptic.CurveParams "".err (type.error "".k  $type.*math/big.Int "".rand type.io.Reader "".c  4type.crypto/elliptic.Curve 
	hq z 6| " 
 TgclocalsÂ·808d8a83f3ee88717356789ffec2964a TgclocalsÂ·ad5dfc73494270c017e0b3c0d2659d72   Œ/home/lintel/PandoraBox-MT7620/build_dir/toolchain-mipsel_24kec+dsp_gcc-4.8-linaro_uClibc-1.0.x/golang-1.4.2/src/crypto/ecdsa/ecdsa.goş"".GenerateKey  °  ° Â  <  ¥$+@¢  %         Ìÿ½'  ¿¯8 ¡ ¡¯< ¡L  ¯ ¡¯@ ¡P  ¯ ¡¯D ¡H  ¯ ¡¯        ¡ £  ¡¯ ¡L £¯P ¡¯ `%   ¿ à4 ½'  <  !$ ¡¯        £ £¯ ¡  H £¯   ¬8 ¡ ¡¯< ¡ ¡¯       H ¡ ¡¯ ¡         ¬ ¡ "$  ¡ ¢¯ ¡¯         ¡ ¡¯        ¡'  %Œ #Œ $Œ( ¥¯ ¥¯, ¤¯ ¤¯0 £¯ £¯8 ¡' "Œ ¢¯  !Œ$ !Œ	ø       ¡$ ¡¯H ¡ ¡¯ ¡ £         ¬ ¡ £¯ "$ ¢¯%        H ¡ ¡¯ ¡         ¬ ¡ "$$ ¡ ¢¯ ¡¯         ¿ à4 ½'    €€¨Ê„€€…x "".GenerateKey   0€€€À 0runtime.morestack_noctxt   ¨€€€À &"".randFieldElement   €€ˆÂ„€€x $type."".PrivateKey   ¨€€€À "runtime.newobject   ˆ€€€À 2runtime.writebarrieriface   ğ€€€À .runtime.writebarrierptr   €€€À *math/big.(*Int).Bytes   ˜       ˜€€€À .runtime.writebarrierptr   €€€€À .runtime.writebarrierptr   8`  "".autotmp_0018 $type.*math/big.Int "".autotmp_0016 type.[]uint8 "".k '$type.*math/big.Int "".err (type.error "".priv  &type.*"".PrivateKey "".rand type.io.Reader "".c  4type.crypto/elliptic.Curve 
	hm v Hœ
2  ! TgclocalsÂ·6fb4fb63b12ef264578672d24f7e049a TgclocalsÂ·b44d60a42acfad6fdbfa8904402ef0a6   Œ/home/lintel/PandoraBox-MT7620/build_dir/toolchain-mipsel_24kec+dsp_gcc-4.8-linaro_uClibc-1.0.x/golang-1.4.2/src/crypto/ecdsa/ecdsa.goş"".hashToInt  °  ° Â  <  ¥$+@¢  %         àÿ½'  ¿¯0 ¡' "Œ ¢¯  !Œ  !Œ	ø       £ bŒ%  ¢¯        £ £¯ c$Ã B !# Ã  ( ¡* 3 `% , ¥% +¤  `%         
 % ( ¤¯% $ ¦, ¥¯$ ¦¯  <  !$ ¡¯       $ ¡ £ ¡¯( ¡ ¡¯, ¡ £¯ ¡¯        ¢( ¡ ¤À #" 
 `     ¤¯ ¤¯ ¤¯% %  £¯        ¤% 8 ¤¯  ¿ à  ½'0      €€¨Ê„€€…x "".hashToInt   0€€€À 0runtime.morestack_noctxt   x       ¨€€€À ,math/big.(*Int).BitLen   ¸€€€À $runtime.panicslice   €€€ˆÂ„€€x "type.math/big.Int   ˜€€€À "runtime.newobject   è€€€À 0math/big.(*Int).SetBytes   à€€€À &math/big.(*Int).Rsh    à€€€ "".hashToInt   08  "".autotmp_0025  type.int "".autotmp_0024  type.int "".autotmp_0021  type.int "".ret $type.*math/big.Int "".orderBits type.int "".~r2 ($type.*math/big.Int "".c 4type.crypto/elliptic.Curve "".hash  type.[]uint8 
	@M V 8Â
		  =
 TgclocalsÂ·d4064a15a268e69e05eeeca6eb6f8ff6 TgclocalsÂ·e1ae6533a9e39048ba0735a2264ce16a   Œ/home/lintel/PandoraBox-MT7620/build_dir/toolchain-mipsel_24kec+dsp_gcc-4.8-linaro_uClibc-1.0.x/golang-1.4.2/src/crypto/ecdsa/ecdsa.goş "".fermatInverse  °  ° Â  <  ¥$+@¢  %         àÿ½'  ¿¯ $%   ¡¯  ¯        £  <  !$ £¯ ¡¯       ( ¡ £ ¡¯ ¡ £¯ ¡¯        £  <  !$ £¯ ¡¯       $ ¡ £ ¡¯ ¡ ¡¯( ¡ £¯ ¡¯        £% , £¯  ¿ à  ½'€€¨Ê„€€…x  "".fermatInverse   0€€€À 0runtime.morestack_noctxt   p€€€À math/big.NewInt   ˆ€€ˆÂ„€€x "type.math/big.Int   ¨€€€À "runtime.newobject   è€€€À &math/big.(*Int).Sub   €€€ˆÂ„€€x "type.math/big.Int    €€€À "runtime.newobject   ğ€€€À &math/big.(*Int).Exp   8  "".autotmp_0035  $type.*math/big.Int "".autotmp_0034  $type.*math/big.Int "".autotmp_0032  $type.*math/big.Int "".nMinus2 $type.*math/big.Int "".two $type.*math/big.Int "".~r2 $type.*math/big.Int "".N $type.*math/big.Int "".k  $type.*math/big.Int 
	@- 6 $è
  
 TgclocalsÂ·3cd76c4f8d01c613585e17871258aa07 TgclocalsÂ·fd4b7947caa1e98312cfd5cb0fa3bc84   Œ/home/lintel/PandoraBox-MT7620/build_dir/toolchain-mipsel_24kec+dsp_gcc-4.8-linaro_uClibc-1.0.x/golang-1.4.2/src/crypto/ecdsa/ecdsa.goş"".Sign       Â  <  ¥$+@¢  %         ´ÿ½'  ¿¯p  ¯t  ¯X ¡l  ¯  "Œ0 ¢¯ "Œ4 ¢¯0 ¡' "Œ ¢¯  !Œ  !Œ	ø       £ bŒ, ¢¯0 ¡ ¡¯4 ¡ ¡¯P ¡ ¡¯T ¡ ¡¯        ¡ £ ¤t ¡¯ €p ¤¯%  h  ¯  ¿ àL ½'$ £¯, ¡ £¯ ¡¯        £$ ¡  £¯ ¡¯        ¡'  %Œ #Œ $ŒX ¡  "Œ8 ¢¯ "Œ< ¢¯@ ¥¯ ¥¯D ¤¯ ¤¯H £¯ £¯8 ¡' "Œ ¢¯  !Œ$ !Œ	ø       £, ¡ £¯h £¯ £¯ ¡¯       h £ bŒO @%  %  »ÿ`    \ ¡ ¡¯` ¡ ¡¯d ¡ ¡¯0 ¡ ¡¯4 ¡ ¡¯        £  <  !$( £¯ ¡¯        £X ¡ £¯ "Œh ¡ ¢¯ ¡¯        £( ¡ £¯l £¯ £¯ ¡¯       l £  ¡ £¯ £¯ ¡¯       l £, ¡ £¯ £¯ ¡¯       l £ bŒ @%  %  ‚ÿ`%   ¿ àL ½'  a€  % ÿÿ$yÿ`%   ¿ àL ½' $sÿ`%   ¿ àL ½'  a€  % `  ÿÿ$`   $"€€¨Ê„€€…x "".Sign   0€€€À 0runtime.morestack_noctxt   ¸        €€€À &"".randFieldElement   ¨€€€À  "".fermatInverse   Ø€€€À *math/big.(*Int).Bytes   ˆ       È€€€À &math/big.(*Int).Mod   à€€€À "".hashToInt   ø€€ˆÂ„€€x "type.math/big.Int   ˜€€€À "runtime.newobject   à€€€À &math/big.(*Int).Mul    €€€À &math/big.(*Int).Add   Ø€€€À &math/big.(*Int).Mul   	€€€À &math/big.(*Int).Mod   €À€€ "".Sign   À€€ "".Sign   P  "".autotmp_0043  type.int "".autotmp_0041  $type.*math/big.Int "".autotmp_0040  $type.*math/big.Int "".autotmp_0038 type.[]uint8 "".e G$type.*math/big.Int "".kInv W$type.*math/big.Int "".k O$type.*math/big.Int "".N ?$type.*math/big.Int "".c 74type.crypto/elliptic.Curve "".err @type.error "".s 8$type.*math/big.Int "".r 0$type.*math/big.Int "".hash type.[]uint8 "".priv &type.*"".PrivateKey "".rand  type.io.Reader 	˜« ´ xü



	
	
 * ) TgclocalsÂ·275557840777af8ce3b59686ef521191 TgclocalsÂ·cb642a313c683b350cd167d798ceb596   Œ/home/lintel/PandoraBox-MT7620/build_dir/toolchain-mipsel_24kec+dsp_gcc-4.8-linaro_uClibc-1.0.x/golang-1.4.2/src/crypto/ecdsa/ecdsa.goş"".Verify  Ğ  Ğ Â  <  ¥$+@¢  %         ¨ÿ½'  ¿¯ÿ 0\ ¡  "ŒD ¢¯ "ŒH ¢¯D ¡' "Œ ¢¯  !Œ  !Œ	ø      l ¥ ¡ ¢Œ &Œö @%  %  ç `    p £ bŒè @%  %  à `     ¥¯% @ ¦¯ ¦¯        £Ò a    p ¡ ¡¯@ ¡ ¡¯        £É a    ` ¡ ¡¯d ¡ ¡¯h ¡ ¡¯D ¡ ¡¯H ¡ ¡¯        £  <  !$< £¯ ¡¯       p ¡ £ ¡¯@ ¡ £¯ ¡¯       < ¤ £ ¤¯ ¤¯% 0 £¯ £¯        £@ ¡ £¯8 £¯ £¯ ¡¯       0 £l ¡ £¯ ¡¯%  £¯        £@ ¡ £¯4 £¯ £¯ ¡¯       8 ¡ ¡¯        ¡'  %Œ #Œ $ŒL ¥¯ ¥¯P ¤¯ ¤¯T £¯ £¯D ¡' "Œ ¢¯  !Œ$ !Œ	ø       ¡( ¡¯ ¡$ ¡¯4 ¡ ¡¯        ¡'\ ¦ #Œ ÂŒ $Œ  %Œ ¢¯ ÂŒD ¡' ¢¯L ¥¯ ¥¯P ¤¯ ¤¯T £¯ £¯ "Œ ¢¯  !Œ( !Œ	ø      ( ¡ ¤ ¡¯ ¤¯$ ¡  £ ¡¯ £¯D ¡' "Œ ¢¯  !Œ !Œ	ø       ¤ ‚Œ ¥? @%0 %   `     ¢Œ% % @%( %   `    ÿ 0t ¡£  ¿ àX ½' ¤¯, ¤¯@ ¡ ¤¯ ¡¯       , ¡ ¡¯l ¡ ¡¯        £ `    %  ÿ 0t ¢£  ¿ àX ½' $ÿ "0t ¢£  ¿ àX ½'  a€	  % ÿÿ$ßÿ`    ÿ 0t ¡£  ¿ àX ½' $×ÿ`    ÿ 0t ¡£  ¿ àX ½'  €  % ½  ÿÿ$½   $ÿ 0t ¡£  ¿ àX ½'ÿ 0t ¡£  ¿ àX ½'  a€  % %  ÿÿ$%   $  ¡€  %   ÿÿ$   $    4€€¨Ê„€€…x "".Verify   0€€€À 0runtime.morestack_noctxt   ¨       Ø€€€À &math/big.(*Int).Cmp    €€€À &math/big.(*Int).Cmp   ˜€€€À "".hashToInt   °€€ˆÂ„€€x "type.math/big.Int   Ğ€€€À "runtime.newobject   €€€À 4math/big.(*Int).ModInverse   Ø€€€À &math/big.(*Int).Mul   ˜€€€À &math/big.(*Int).Mod   Ø€€€À &math/big.(*Int).Mul   ˜€€€À &math/big.(*Int).Mod   ¸€€€À *math/big.(*Int).Bytes   À       €	€€€À *math/big.(*Int).Bytes   °
       ¨       €€€€À &math/big.(*Int).Mod   °€€€À &math/big.(*Int).Cmp   èú‚€€ "".Verify   øú‚€€ "".Verify   ğÊ€€€ "".Verify   €Ê€€€ "".Verify   ¨¼€€€ "".Verify   ¸¼€€€ "".Verify   8¨  0"".autotmp_0059  type.int "".autotmp_0058  type.int "".autotmp_0057  type.int "".autotmp_0056  type.[]uint8 "".autotmp_0055 type.[]uint8 "".autotmp_0054  $type.*math/big.Int "".autotmp_0053  $type.*math/big.Int "".autotmp_0051  $type.*math/big.Int "".autotmp_0048  type.int "".autotmp_0047  type.int "".x W$type.*math/big.Int 
"".y1 g$type.*math/big.Int 
"".x1 _$type.*math/big.Int 
"".u2 G$type.*math/big.Int 
"".u1 ?$type.*math/big.Int "".w O$type.*math/big.Int "".e 7$type.*math/big.Int "".N /$type.*math/big.Int "".c '4type.crypto/elliptic.Curve "".~r4 0type.bool "".s ($type.*math/big.Int "".r  $type.*math/big.Int "".hash type.[]uint8 "".pub  $type.*"".PublicKey 	°‘ š ”Æ	
 6 %D TgclocalsÂ·8079dab6f601396bca1f5af3d7ec60a6 TgclocalsÂ·2a6a26631730f601ffb9dadc3e33c5c5   Œ/home/lintel/PandoraBox-MT7620/build_dir/toolchain-mipsel_24kec+dsp_gcc-4.8-linaro_uClibc-1.0.x/golang-1.4.2/src/crypto/ecdsa/ecdsa.goş"".init  À  À Â  <  ¥$+@¢  %         ìÿ½'  ¿¯  <  9'  !“       $  <  9'  !“ÿ B0 "      ¿ à ½'        
  $ÿ !0  <  9'  !£                                     <  !$ ¡¯        $%   £  ¯ £¯ ¡¯         <  !$ £ ¡¯%  £¯        $ÿ !0  <  9'  !£  ¿ à ½'"€€¨Ê„€€…x "".init   0€€€À 0runtime.morestack_noctxt   P€€Èó„€€™x "".initdoneÂ·   €€€Èó„€€™x "".initdoneÂ·   È€€€À "runtime.throwinit   ğ€€Èó„€€™x "".initdoneÂ·   ˆ€€€À math/big.init   ˜€€€À io.init   ¨€€€À $encoding/asn1.init   ¸€€€À (crypto/elliptic.init   È€€€À crypto.init   Ø€€ˆÂ„€€x "type.math/big.Int   ğ€€€À "runtime.newobject   °€€€À 0math/big.(*Int).SetInt64   À€€ˆÂ„€€x "".one   ğ€€€À .runtime.writebarrierptr   €€Èó„€€™x "".initdoneÂ·        
	(? H ü+‡ˆ 
 / TgclocalsÂ·3280bececceccd33cb74587feedb1f9f TgclocalsÂ·3280bececceccd33cb74587feedb1f9f   Œ/home/lintel/PandoraBox-MT7620/build_dir/toolchain-mipsel_24kec+dsp_gcc-4.8-linaro_uClibc-1.0.x/golang-1.4.2/src/crypto/ecdsa/ecdsa.goş.type..hash."".PublicKey ğ  ğ Â  <  ¥$+@¢  %         ìÿ½'  ¿¯ ¡ ¡¯ ¡         ¬ $ ¡¯  ¡ ¡¯        ¡ ¡¯ ¡ £         ¬  £¯ ¡ £¯ "$ ¢¯ $ ¡¯%         £% $ £¯  ¿ à ½'    €€¨Ê„€€…x .type..hash."".PublicKey   0€€€À 0runtime.morestack_noctxt    €€€À "runtime.interhash   ¨€€€À runtime.memhash       
"".autotmp_0063  type.uintptr "".~r3 type.uintptr "".h type.uintptr "".s type.uintptr "".p  $type.*"".PublicKey 
	(% . . 
  TgclocalsÂ·2dc77d960dd3e4b3de2361f9cbd75783 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f   Œ/home/lintel/PandoraBox-MT7620/build_dir/toolchain-mipsel_24kec+dsp_gcc-4.8-linaro_uClibc-1.0.x/golang-1.4.2/src/crypto/ecdsa/ecdsa.goş*type..eq."".PublicKey °  ° Â  <  ¥$+@¢  %         Øÿ½'  ¿¯ÿ 00 ¡  "Œ  ¢¯ "Œ, ¡$ ¢¯  "Œ ¢¯ "Œ ¡ ¢¯  ¢( "     ¢ ¢¯ ¢ ¢¯  ¢ ¢¯$ ¢ ¢¯        ¡“0 ¥, ¤       Œ ¢Œ "% ÿ 08 ¡£  ¿ à( ½' Œ ¢Œ "% ÿ 08 ¡£  ¿ à( ½' $ÿ !08 ¡£  ¿ à( ½'ÿ 08 ¡£  ¿ à( ½'    €€¨Ê„€€…x *type..eq."".PublicKey   0€€€À 0runtime.morestack_noctxt   ˆ€€€À runtime.ifaceeq    H  "".autotmp_0065 4type.crypto/elliptic.Curve "".autotmp_0064 4type.crypto/elliptic.Curve "".~r3 type.bool "".s type.uintptr "".q $type.*"".PublicKey "".p  $type.*"".PublicKey 
	P= F F 
 !% TgclocalsÂ·9c703c5c7b9c1932c840b69f8ebce236 TgclocalsÂ·44568aa369055d8938d809aa5d80843b   Œ/home/lintel/PandoraBox-MT7620/build_dir/toolchain-mipsel_24kec+dsp_gcc-4.8-linaro_uClibc-1.0.x/golang-1.4.2/src/crypto/ecdsa/ecdsa.goş&"".(*PublicKey).Add €  € Â  <  ¥$+@¢  %         Øÿ½'  ¿¯ Á        "Œ, £' C     ¤'  $¬, ¡  "Œ  ¢¯ "Œ0 ¡ ¡¯4 ¡ ¡¯8 ¡ ¡¯< ¡$ ¢¯ ¡¯  ¡' "Œ ¢¯  !Œ !Œ	ø       ¤ £@ ¤¯% D £¯  ¿ à( ½'    €€¨Ê„€€…x &"".(*PublicKey).Add   0€€€À 0runtime.morestack_noctxt   ¨       8H  "crypto/elliptic.y 0$type.*math/big.Int "crypto/elliptic.x ($type.*math/big.Int $crypto/elliptic.y2  $type.*math/big.Int $crypto/elliptic.x2 $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  $type.*"".PublicKey 
	P' 0 0 
 % TgclocalsÂ·be52d99fd4fc187ec6a3cd1eab5661d9 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş "".PublicKey.Add ğ  ğ Â  <  ¥$+@¢  %         Øÿ½'  ¿¯ Á        "Œ, £' C     ¤'  $¬, ¡  ¡¯0 ¡$ ¡¯< ¡ ¡¯@ ¡ ¡¯D ¡ ¡¯H ¡ ¡¯  ¡' "Œ ¢¯  !Œ !Œ	ø       ¤ £L ¤¯% P £¯  ¿ à( ½'€€¨Ê„€€…x  "".PublicKey.Add   0€€€À 0runtime.morestack_noctxt           PH  "crypto/elliptic.y H$type.*math/big.Int "crypto/elliptic.x @$type.*math/big.Int $crypto/elliptic.y2 8$type.*math/big.Int $crypto/elliptic.x2 0$type.*math/big.Int $crypto/elliptic.y1 ($type.*math/big.Int $crypto/elliptic.x1  $type.*math/big.Int ""..this  "type."".PublicKey 
	P% . . 
 $
 TgclocalsÂ·78ad52f947c0f9e54dd0fb4377b33085 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş,"".(*PublicKey).Double à  à Â  <  ¥$+@¢  %         àÿ½'  ¿¯ Á        "Œ$ £' C     ¤'  $¬$ ¡  "Œ ¢¯ "Œ( ¡ ¡¯, ¡ ¢¯ ¡¯ ¡' "Œ ¢¯  !Œ !Œ	ø       ¤ £0 ¤¯% 4 £¯  ¿ à  ½'    €€¨Ê„€€…x ,"".(*PublicKey).Double   0€€€À 0runtime.morestack_noctxt   ˆ       (8  
"crypto/elliptic.y  $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  $type.*"".PublicKey 
	@# , , 
 ! TgclocalsÂ·6e5d4a330d25067342b1b461a5d19024 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş&"".PublicKey.Double Ğ  Ğ Â  <  ¥$+@¢  %         àÿ½'  ¿¯ Á        "Œ$ £' C     ¤'  $¬$ ¡ ¡¯( ¡ ¡¯4 ¡ ¡¯8 ¡ ¡¯ ¡' "Œ ¢¯  !Œ !Œ	ø       ¤ £< ¤¯% @ £¯  ¿ à  ½'€€¨Ê„€€…x &"".PublicKey.Double   0€€€À 0runtime.morestack_noctxt   €       @8  
"crypto/elliptic.y 8$type.*math/big.Int "crypto/elliptic.x 0$type.*math/big.Int $crypto/elliptic.y1 ($type.*math/big.Int $crypto/elliptic.x1  $type.*math/big.Int ""..this  "type."".PublicKey 
	@! * 
* 
  
 TgclocalsÂ·2c26e9496b1c078fc62b3f021ed30e75 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş2"".(*PublicKey).IsOnCurve à  à Â  <  ¥$+@¢  %         äÿ½'  ¿¯ Á        "Œ  £' C     ¤'  $¬ÿ 0  ¡  "Œ ¢¯ "Œ$ ¡ ¡¯( ¡ ¢¯ ¡¯ ¡' "Œ ¢¯  !Œ !Œ	ø       ¡“ |ÿ a0, ¡£  ¿ à ½'    €€¨Ê„€€…x 2"".(*PublicKey).IsOnCurve   0€€€À 0runtime.morestack_noctxt           0  "".~r3 type.bool "crypto/elliptic.y $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int ""..this  $type.*"".PublicKey 
	8# , , 
 "
 TgclocalsÂ·8d11a518189555fd7f3bac3cc6ad264c TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş,"".PublicKey.IsOnCurve Ğ  Ğ Â  <  ¥$+@¢  %         äÿ½'  ¿¯ Á        "Œ  £' C     ¤'  $¬ÿ 0  ¡ ¡¯$ ¡ ¡¯0 ¡ ¡¯4 ¡ ¡¯ ¡' "Œ ¢¯  !Œ !Œ	ø       ¡“ |ÿ a08 ¡£  ¿ à ½'€€¨Ê„€€…x ,"".PublicKey.IsOnCurve   0€€€À 0runtime.morestack_noctxt   ˆ       80  "".~r3 0type.bool "crypto/elliptic.y ($type.*math/big.Int "crypto/elliptic.x  $type.*math/big.Int ""..this  "type."".PublicKey 
	8! * * 
 !	 TgclocalsÂ·533e41f03c38242213357bdf241c642f TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş,"".(*PublicKey).Params °  ° Â  <  ¥$+@¢  %         ìÿ½'  ¿¯ Á        "Œ £' C     ¤'  $¬ ¡  "Œ ¢¯ "Œ ¢¯ ¡' "Œ ¢¯  !Œ  !Œ	ø       £%  £¯  ¿ à ½'    €€¨Ê„€€…x ,"".(*PublicKey).Params   0€€€À 0runtime.morestack_noctxt   è          "".~r1 Btype.*crypto/elliptic.CurveParams ""..this  $type.*"".PublicKey 
	( & & 
 	 TgclocalsÂ·06cab038d51064a089bda21fa03e00f7 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş&"".PublicKey.Params      Â  <  ¥$+@¢  %         ìÿ½'  ¿¯ Á        "Œ £' C     ¤'  $¬ ¡ ¡¯ ¡ ¡¯ ¡' "Œ ¢¯  !Œ  !Œ	ø       £% ( £¯  ¿ à ½'€€¨Ê„€€…x &"".PublicKey.Params   0€€€À 0runtime.morestack_noctxt   à       (   "".~r1  Btype.*crypto/elliptic.CurveParams ""..this  "type."".PublicKey 
	( $ $ 
  TgclocalsÂ·564befda8e2e8cc7f35f6bc1d3c5e0a6 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş<"".(*PublicKey).ScalarBaseMult ğ  ğ Â  <  ¥$+@¢  %         Üÿ½'  ¿¯ Á        "Œ( £' C     ¤'  $¬( ¡  "Œ ¢¯ "Œ, ¡ ¡¯0 ¡ ¡¯4 ¡  ¢¯ ¡¯ ¡' "Œ ¢¯  !Œ$ !Œ	ø       ¤ £8 ¤¯% < £¯  ¿ à$ ½'    €€¨Ê„€€…x <"".(*PublicKey).ScalarBaseMult   0€€€À 0runtime.morestack_noctxt   ˜       0@  "crypto/elliptic.y ($type.*math/big.Int "crypto/elliptic.x  $type.*math/big.Int "crypto/elliptic.k type.[]uint8 ""..this  $type.*"".PublicKey 
	H% . . 
 # TgclocalsÂ·9f0d5ba6770c4a1ed4fa771547e96df1 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş6"".PublicKey.ScalarBaseMult à  à Â  <  ¥$+@¢  %         Üÿ½'  ¿¯ Á        "Œ( £' C     ¤'  $¬( ¡ ¡¯, ¡  ¡¯8 ¡ ¡¯< ¡ ¡¯@ ¡ ¡¯ ¡' "Œ ¢¯  !Œ$ !Œ	ø       ¤ £D ¤¯% H £¯  ¿ à$ ½'€€¨Ê„€€…x 6"".PublicKey.ScalarBaseMult   0€€€À 0runtime.morestack_noctxt          H@  "crypto/elliptic.y @$type.*math/big.Int "crypto/elliptic.x 8$type.*math/big.Int "crypto/elliptic.k  type.[]uint8 ""..this  "type."".PublicKey 
	H# , , 
 "
 TgclocalsÂ·f4b5958521e1cb5f3b2f5fb10ef93ae8 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş4"".(*PublicKey).ScalarMult    Â  <  ¥$+@¢  %         Ôÿ½'  ¿¯ Á        "Œ0 £' C     ¤'  $¬0 ¡  "Œ$ ¢¯ "Œ4 ¡ ¡¯8 ¡ ¡¯< ¡ ¡¯@ ¡ ¡¯D ¡( ¢¯ ¡¯$ ¡' "Œ ¢¯  !Œ( !Œ	ø       ¤  £H ¤¯% L £¯  ¿ à, ½'    €€¨Ê„€€…x 4"".(*PublicKey).ScalarMult   0€€€À 0runtime.morestack_noctxt   ¸       @P  "crypto/elliptic.y 8$type.*math/big.Int "crypto/elliptic.x 0$type.*math/big.Int "crypto/elliptic.k type.[]uint8 $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  $type.*"".PublicKey 
	X) 2 2 
 ' TgclocalsÂ·6f36ab01c3b1e9831d2d7a8e3c4180c2 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş."".PublicKey.ScalarMult €  € Â  <  ¥$+@¢  %         Ôÿ½'  ¿¯ Á        "Œ0 £' C     ¤'  $¬0 ¡$ ¡¯4 ¡( ¡¯@ ¡ ¡¯D ¡ ¡¯H ¡ ¡¯L ¡ ¡¯P ¡ ¡¯$ ¡' "Œ ¢¯  !Œ( !Œ	ø       ¤  £T ¤¯% X £¯  ¿ à, ½'€€¨Ê„€€…x ."".PublicKey.ScalarMult   0€€€À 0runtime.morestack_noctxt   °       XP  "crypto/elliptic.y P$type.*math/big.Int "crypto/elliptic.x H$type.*math/big.Int "crypto/elliptic.k 0type.[]uint8 $crypto/elliptic.y1 ($type.*math/big.Int $crypto/elliptic.x1  $type.*math/big.Int ""..this  "type."".PublicKey 
	X' 0 0 
 &
 TgclocalsÂ·464a8fa94b68a24c95c5f7d743fa1b72 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş0type..hash."".PrivateKey ğ  ğ Â  <  ¥$+@¢  %         ìÿ½'  ¿¯ ¡ ¡¯ ¡         ¬ $ ¡¯  ¡ ¡¯        ¡ ¡¯ ¡ £         ¬  £¯ ¡ £¯ "$ ¢¯ $ ¡¯%         £% $ £¯  ¿ à ½'    €€¨Ê„€€…x 0type..hash."".PrivateKey   0€€€À 0runtime.morestack_noctxt    €€€À .type..hash."".PublicKey   ¨€€€À runtime.memhash       
"".autotmp_0099  type.uintptr "".~r3 type.uintptr "".h type.uintptr "".s type.uintptr "".p  &type.*"".PrivateKey 
	(% . . 
  TgclocalsÂ·2dc77d960dd3e4b3de2361f9cbd75783 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f   Œ/home/lintel/PandoraBox-MT7620/build_dir/toolchain-mipsel_24kec+dsp_gcc-4.8-linaro_uClibc-1.0.x/golang-1.4.2/src/crypto/ecdsa/ecdsa.goş,type..eq."".PrivateKey Ğ  Ğ Â  <  ¥$+@¢  %         Ğÿ½'  ¿¯4 ¤ €ÿ 0   ¬8 £ £¯  bŒ( ¢¯ bŒ, ¢¯ ¤¯  ‚Œ  ¢¯ ‚Œ  ¡$ ¢¯( ¢) "      ¢ ¢¯$ ¢ ¢¯( ¢ ¢¯, ¢ ¢¯        ¡“ ¥ ¤       ¡Œ ‚Œ "%  ¡Œ ‚Œ "% 4 ¢8 £ AŒ bŒ "    ÿ 0@ ¡£  ¿ à0 ½' $ÿ !0@ ¡£  ¿ à0 ½'ÿ 0@ ¡£  ¿ à0 ½'€€¨Ê„€€…x ,type..eq."".PrivateKey   0€€€À 0runtime.morestack_noctxt   ¨€€€À runtime.ifaceeq    X  "".autotmp_0103 4type.crypto/elliptic.Curve "".autotmp_0102 4type.crypto/elliptic.Curve "".autotmp_0101 /$type.*"".PublicKey "".autotmp_0100 '$type.*"".PublicKey "".~r3 type.bool "".s type.uintptr "".q &type.*"".PrivateKey "".p  &type.*"".PrivateKey 
	`A J J 
 %% TgclocalsÂ·fa7203fd5ed88aea99b7be572f707eb0 TgclocalsÂ·65526a5f07004f02424fe51b799cdd23   Œ/home/lintel/PandoraBox-MT7620/build_dir/toolchain-mipsel_24kec+dsp_gcc-4.8-linaro_uClibc-1.0.x/golang-1.4.2/src/crypto/ecdsa/ecdsa.goş("".(*PrivateKey).Add €  € Â  <  ¥$+@¢  %         Øÿ½'  ¿¯ Á        "Œ, £' C     ¤'  $¬, ¡  "Œ  ¢¯ "Œ0 ¡ ¡¯4 ¡ ¡¯8 ¡ ¡¯< ¡$ ¢¯ ¡¯  ¡' "Œ ¢¯  !Œ !Œ	ø       ¤ £@ ¤¯% D £¯  ¿ à( ½'    €€¨Ê„€€…x ("".(*PrivateKey).Add   0€€€À 0runtime.morestack_noctxt   ¨       8H  "crypto/elliptic.y 0$type.*math/big.Int "crypto/elliptic.x ($type.*math/big.Int $crypto/elliptic.y2  $type.*math/big.Int $crypto/elliptic.x2 $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  &type.*"".PrivateKey 
	P' 0 0 
 % TgclocalsÂ·be52d99fd4fc187ec6a3cd1eab5661d9 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş""".PrivateKey.Add ğ  ğ Â  <  ¥$+@¢  %         Øÿ½'  ¿¯ Á        "Œ, £' C     ¤'  $¬, ¡  ¡¯0 ¡$ ¡¯@ ¡ ¡¯D ¡ ¡¯H ¡ ¡¯L ¡ ¡¯  ¡' "Œ ¢¯  !Œ !Œ	ø       ¤ £P ¤¯% T £¯  ¿ à( ½'€€¨Ê„€€…x """.PrivateKey.Add   0€€€À 0runtime.morestack_noctxt           XH  "crypto/elliptic.y P$type.*math/big.Int "crypto/elliptic.x H$type.*math/big.Int $crypto/elliptic.y2 @$type.*math/big.Int $crypto/elliptic.x2 8$type.*math/big.Int $crypto/elliptic.y1 0$type.*math/big.Int $crypto/elliptic.x1 ($type.*math/big.Int ""..this  $type."".PrivateKey 
	P% . . 
 $
 TgclocalsÂ·d0639bedff7ffedcd56695753d30706e TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş."".(*PrivateKey).Double à  à Â  <  ¥$+@¢  %         àÿ½'  ¿¯ Á        "Œ$ £' C     ¤'  $¬$ ¡  "Œ ¢¯ "Œ( ¡ ¡¯, ¡ ¢¯ ¡¯ ¡' "Œ ¢¯  !Œ !Œ	ø       ¤ £0 ¤¯% 4 £¯  ¿ à  ½'    €€¨Ê„€€…x ."".(*PrivateKey).Double   0€€€À 0runtime.morestack_noctxt   ˆ       (8  
"crypto/elliptic.y  $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  &type.*"".PrivateKey 
	@# ,  , 
 ! TgclocalsÂ·6e5d4a330d25067342b1b461a5d19024 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş("".PrivateKey.Double Ğ  Ğ Â  <  ¥$+@¢  %         àÿ½'  ¿¯ Á        "Œ$ £' C     ¤'  $¬$ ¡ ¡¯( ¡ ¡¯8 ¡ ¡¯< ¡ ¡¯ ¡' "Œ ¢¯  !Œ !Œ	ø       ¤ £@ ¤¯% D £¯  ¿ à  ½'€€¨Ê„€€…x ("".PrivateKey.Double   0€€€À 0runtime.morestack_noctxt   €       H8  
"crypto/elliptic.y @$type.*math/big.Int "crypto/elliptic.x 8$type.*math/big.Int $crypto/elliptic.y1 0$type.*math/big.Int $crypto/elliptic.x1 ($type.*math/big.Int ""..this  $type."".PrivateKey 
	@! * "* 
  
 TgclocalsÂ·dd6da6b6c0a8ea1724ec8c8531209fd3 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş4"".(*PrivateKey).IsOnCurve à  à Â  <  ¥$+@¢  %         äÿ½'  ¿¯ Á        "Œ  £' C     ¤'  $¬ÿ 0  ¡  "Œ ¢¯ "Œ$ ¡ ¡¯( ¡ ¢¯ ¡¯ ¡' "Œ ¢¯  !Œ !Œ	ø       ¡“ |ÿ a0, ¡£  ¿ à ½'    €€¨Ê„€€…x 4"".(*PrivateKey).IsOnCurve   0€€€À 0runtime.morestack_noctxt           0  "".~r3 type.bool "crypto/elliptic.y $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int ""..this  &type.*"".PrivateKey 
	8# , $, 
 "
 TgclocalsÂ·8d11a518189555fd7f3bac3cc6ad264c TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş."".PrivateKey.IsOnCurve Ğ  Ğ Â  <  ¥$+@¢  %         äÿ½'  ¿¯ Á        "Œ  £' C     ¤'  $¬ÿ 0  ¡ ¡¯$ ¡ ¡¯4 ¡ ¡¯8 ¡ ¡¯ ¡' "Œ ¢¯  !Œ !Œ	ø       ¡“ |ÿ a0< ¡£  ¿ à ½'€€¨Ê„€€…x ."".PrivateKey.IsOnCurve   0€€€À 0runtime.morestack_noctxt   ˆ       @0  "".~r3 8type.bool "crypto/elliptic.y 0$type.*math/big.Int "crypto/elliptic.x ($type.*math/big.Int ""..this  $type."".PrivateKey 
	8! * &* 
 !	 TgclocalsÂ·dafc2a4ed1eccf20e0ba3ca784d254a7 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş."".(*PrivateKey).Params °  ° Â  <  ¥$+@¢  %         ìÿ½'  ¿¯ Á        "Œ £' C     ¤'  $¬ ¡  "Œ ¢¯ "Œ ¢¯ ¡' "Œ ¢¯  !Œ  !Œ	ø       £%  £¯  ¿ à ½'    €€¨Ê„€€…x ."".(*PrivateKey).Params   0€€€À 0runtime.morestack_noctxt   è          "".~r1 Btype.*crypto/elliptic.CurveParams ""..this  &type.*"".PrivateKey 
	( & (& 
 	 TgclocalsÂ·06cab038d51064a089bda21fa03e00f7 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş("".PrivateKey.Params      Â  <  ¥$+@¢  %         ìÿ½'  ¿¯ Á        "Œ £' C     ¤'  $¬ ¡ ¡¯ ¡ ¡¯ ¡' "Œ ¢¯  !Œ  !Œ	ø       £% , £¯  ¿ à ½'€€¨Ê„€€…x ("".PrivateKey.Params   0€€€À 0runtime.morestack_noctxt   à       0   "".~r1 (Btype.*crypto/elliptic.CurveParams ""..this  $type."".PrivateKey 
	( $ *$ 
  TgclocalsÂ·743023cec9b4b515d11a8fbfd57d92fa TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş>"".(*PrivateKey).ScalarBaseMult ğ  ğ Â  <  ¥$+@¢  %         Üÿ½'  ¿¯ Á        "Œ( £' C     ¤'  $¬( ¡  "Œ ¢¯ "Œ, ¡ ¡¯0 ¡ ¡¯4 ¡  ¢¯ ¡¯ ¡' "Œ ¢¯  !Œ$ !Œ	ø       ¤ £8 ¤¯% < £¯  ¿ à$ ½'    €€¨Ê„€€…x >"".(*PrivateKey).ScalarBaseMult   0€€€À 0runtime.morestack_noctxt   ˜       0@  "crypto/elliptic.y ($type.*math/big.Int "crypto/elliptic.x  $type.*math/big.Int "crypto/elliptic.k type.[]uint8 ""..this  &type.*"".PrivateKey 
	H% . ,. 
 # TgclocalsÂ·9f0d5ba6770c4a1ed4fa771547e96df1 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş8"".PrivateKey.ScalarBaseMult à  à Â  <  ¥$+@¢  %         Üÿ½'  ¿¯ Á        "Œ( £' C     ¤'  $¬( ¡ ¡¯, ¡  ¡¯< ¡ ¡¯@ ¡ ¡¯D ¡ ¡¯ ¡' "Œ ¢¯  !Œ$ !Œ	ø       ¤ £H ¤¯% L £¯  ¿ à$ ½'€€¨Ê„€€…x 8"".PrivateKey.ScalarBaseMult   0€€€À 0runtime.morestack_noctxt          P@  "crypto/elliptic.y H$type.*math/big.Int "crypto/elliptic.x @$type.*math/big.Int "crypto/elliptic.k (type.[]uint8 ""..this  $type."".PrivateKey 
	H# , ., 
 "
 TgclocalsÂ·fb6dce094c1dd234d359f74ad2ce663f TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş6"".(*PrivateKey).ScalarMult    Â  <  ¥$+@¢  %         Ôÿ½'  ¿¯ Á        "Œ0 £' C     ¤'  $¬0 ¡  "Œ$ ¢¯ "Œ4 ¡ ¡¯8 ¡ ¡¯< ¡ ¡¯@ ¡ ¡¯D ¡( ¢¯ ¡¯$ ¡' "Œ ¢¯  !Œ( !Œ	ø       ¤  £H ¤¯% L £¯  ¿ à, ½'    €€¨Ê„€€…x 6"".(*PrivateKey).ScalarMult   0€€€À 0runtime.morestack_noctxt   ¸       @P  "crypto/elliptic.y 8$type.*math/big.Int "crypto/elliptic.x 0$type.*math/big.Int "crypto/elliptic.k type.[]uint8 $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  &type.*"".PrivateKey 
	X) 2 02 
 ' TgclocalsÂ·6f36ab01c3b1e9831d2d7a8e3c4180c2 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş0"".PrivateKey.ScalarMult €  € Â  <  ¥$+@¢  %         Ôÿ½'  ¿¯ Á        "Œ0 £' C     ¤'  $¬0 ¡$ ¡¯4 ¡( ¡¯D ¡ ¡¯H ¡ ¡¯L ¡ ¡¯P ¡ ¡¯T ¡ ¡¯$ ¡' "Œ ¢¯  !Œ( !Œ	ø       ¤  £X ¤¯% \ £¯  ¿ à, ½'€€¨Ê„€€…x 0"".PrivateKey.ScalarMult   0€€€À 0runtime.morestack_noctxt   °       `P  "crypto/elliptic.y X$type.*math/big.Int "crypto/elliptic.x P$type.*math/big.Int "crypto/elliptic.k 8type.[]uint8 $crypto/elliptic.y1 0$type.*math/big.Int $crypto/elliptic.x1 ($type.*math/big.Int ""..this  $type."".PrivateKey 
	X' 0 20 
 &
 TgclocalsÂ·820c449159202a11cc0e8f118b89b1ba TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·a08e9001cb8f9d822225de3b8e406515             şTgclocalsÂ·1c5b1c90a4c2549bb9ca6a7854f35d0e                    şTgclocalsÂ·df47e04495aeec9ad0763bc648c6b4e3           ®°  ®°   şTgclocalsÂ·ad5dfc73494270c017e0b3c0d2659d72 P  P                 
   
              şTgclocalsÂ·808d8a83f3ee88717356789ffec2964a P  P      »   »  »  »  »,  »,  ».  ».   şTgclocalsÂ·b44d60a42acfad6fdbfa8904402ef0a6 @  @   
                         şTgclocalsÂ·6fb4fb63b12ef264578672d24f7e049a @  @      »   »  »,  ».  ».  ».   şTgclocalsÂ·e1ae6533a9e39048ba0735a2264ce16a                   şTgclocalsÂ·d4064a15a268e69e05eeeca6eb6f8ff6           Â  Â   şTgclocalsÂ·fd4b7947caa1e98312cfd5cb0fa3bc84 (  (                 şTgclocalsÂ·3cd76c4f8d01c613585e17871258aa07 (  (      
   
   
    şTgclocalsÂ·cb642a313c683b350cd167d798ceb596 X  X	             €  ˆ  ‚  ‚  ‚  ¢  €   şTgclocalsÂ·275557840777af8ce3b59686ef521191 X  X	      «   «€  «€  «€ «€ «  «  «  «   şTgclocalsÂ·2a6a26631730f601ffb9dadc3e33c5c5 p  p              €    €€ €ˆ  ˆ  Š  ‚ 
€  €       şTgclocalsÂ·8079dab6f601396bca1f5af3d7ec60a6 p  p      

  

  

  

  

  

  

  

  

  

  

  

   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           ş*"".one  $type.*math/big.Int   ş,"".initdoneÂ·  type.uint8   ş4"".(*PrivateKey).PublicÂ·f          ."".(*PrivateKey).Public   ş,runtime.throwreturnÂ·f          &runtime.throwreturn   ş0"".(*PrivateKey).SignÂ·f          *"".(*PrivateKey).Sign   ş"".SignÂ·f          "".Sign   ş$runtime.convT2EÂ·f          runtime.convT2E   ş0encoding/asn1.MarshalÂ·f          *encoding/asn1.Marshal   ş,"".randFieldElementÂ·f          &"".randFieldElement   ş(runtime.makesliceÂ·f          "runtime.makeslice   şio.ReadFullÂ·f          io.ReadFull   ş(runtime.newobjectÂ·f          "runtime.newobject   ş6math/big.(*Int).SetBytesÂ·f          0math/big.(*Int).SetBytes   ş,math/big.(*Int).SubÂ·f          &math/big.(*Int).Sub   ş,math/big.(*Int).ModÂ·f          &math/big.(*Int).Mod   ş,math/big.(*Int).AddÂ·f          &math/big.(*Int).Add   ş""".GenerateKeyÂ·f          "".GenerateKey   ş8runtime.writebarrierifaceÂ·f          2runtime.writebarrieriface   ş4runtime.writebarrierptrÂ·f          .runtime.writebarrierptr   ş0math/big.(*Int).BytesÂ·f          *math/big.(*Int).Bytes   ş"".hashToIntÂ·f          "".hashToInt   ş2math/big.(*Int).BitLenÂ·f          ,math/big.(*Int).BitLen   ş*runtime.panicsliceÂ·f          $runtime.panicslice   ş,math/big.(*Int).RshÂ·f          &math/big.(*Int).Rsh   ş&"".fermatInverseÂ·f           "".fermatInverse   ş$math/big.NewIntÂ·f          math/big.NewInt   ş,math/big.(*Int).ExpÂ·f          &math/big.(*Int).Exp   ş,math/big.(*Int).MulÂ·f          &math/big.(*Int).Mul   ş"".VerifyÂ·f          "".Verify   ş,math/big.(*Int).CmpÂ·f          &math/big.(*Int).Cmp   ş:math/big.(*Int).ModInverseÂ·f          4math/big.(*Int).ModInverse   ş"".initÂ·f          "".init   ş(runtime.throwinitÂ·f          "runtime.throwinit   ş math/big.initÂ·f          math/big.init   şio.initÂ·f          io.init   ş*encoding/asn1.initÂ·f          $encoding/asn1.init   ş.crypto/elliptic.initÂ·f          (crypto/elliptic.init   şcrypto.initÂ·f          crypto.init   ş6math/big.(*Int).SetInt64Â·f          0math/big.(*Int).SetInt64   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·2dc77d960dd3e4b3de2361f9cbd75783             şTgclocalsÂ·44568aa369055d8938d809aa5d80843b              şTgclocalsÂ·9c703c5c7b9c1932c840b69f8ebce236             ş6type..hashfunc."".PublicKey          .type..hash."".PublicKey   ş2type..eqfunc."".PublicKey          *type..eq."".PublicKey   ş,type..alg."".PublicKey              6type..hashfunc."".PublicKey     2type..eqfunc."".PublicKey   şBruntime.gcbits.0x8c88000000000000   Œˆ       ş6go.string."ecdsa.PublicKey" 0  0       ecdsa.PublicKey   6go.string."ecdsa.PublicKey"   şgo.string."X"          X   go.string."X"   şgo.string."Y"          Y   go.string."Y"   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·be52d99fd4fc187ec6a3cd1eab5661d9         ª   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·78ad52f947c0f9e54dd0fb4377b33085         «ª   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·6e5d4a330d25067342b1b461a5d19024      
   *    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·2c26e9496b1c078fc62b3f021ed30e75         «
   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·8d11a518189555fd7f3bac3cc6ad264c         *    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·533e41f03c38242213357bdf241c642f         «
   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·06cab038d51064a089bda21fa03e00f7             şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·564befda8e2e8cc7f35f6bc1d3c5e0a6      
   «    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·9f0d5ba6770c4a1ed4fa771547e96df1         
    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·f4b5958521e1cb5f3b2f5fb10ef93ae8         «   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·6f36ab01c3b1e9831d2d7a8e3c4180c2         ª    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·464a8fa94b68a24c95c5f7d743fa1b72         «*   şBruntime.gcbits.0x8800000000000000   ˆ        ş¼go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ¸  ¶    R   func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)   ¼go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) À  À   ôgİz 3                                                                                °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ¼go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  ögo.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p° ätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  "type."".PublicKey     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ¸  $type.*math/big.Int   ş”go.string."func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"       >   func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)   ”go.string."func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   ş¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) °  °   º|¶ù 3                                                                        °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ”go.string."func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  ºgo.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p  ¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  "type."".PublicKey     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   ştgo.string."func(ecdsa.PublicKey, *big.Int, *big.Int) bool" p  n    .   func(ecdsa.PublicKey, *big.Int, *big.Int) bool   tgo.string."func(ecdsa.PublicKey, *big.Int, *big.Int) bool"   şttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool ¨  ¨   Å 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  tgo.string."func(ecdsa.PublicKey, *big.Int, *big.Int) bool"   @  †go.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int) bool   H  "runtime.zerovalue   Xˆ ttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool   p  ttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool   ˆ  "type."".PublicKey     $type.*math/big.Int   ˜  $type.*math/big.Int      type.bool   şngo.string."func(ecdsa.PublicKey) *elliptic.CurveParams" h  h    +   func(ecdsa.PublicKey) *elliptic.CurveParams   ngo.string."func(ecdsa.PublicKey) *elliptic.CurveParams"   şhtype.func("".PublicKey) *crypto/elliptic.CurveParams ˜  ˜   ¶ñÓ± 3                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ngo.string."func(ecdsa.PublicKey) *elliptic.CurveParams"   @  zgo.weak.type.*func("".PublicKey) *crypto/elliptic.CurveParams   H  "runtime.zerovalue   Xˆ htype.func("".PublicKey) *crypto/elliptic.CurveParams   p htype.func("".PublicKey) *crypto/elliptic.CurveParams   ˆ  "type."".PublicKey     Btype.*crypto/elliptic.CurveParams   şBruntime.gcbits.0x4884440000000000   H„D      ş&go.string."[]uint8"            []uint8   &go.string."[]uint8"   ştype.[]uint8 X  X   ß~.8                                   runtime.algarray      Bruntime.gcbits.0x4884440000000000   0  &go.string."[]uint8"   @  *go.weak.type.*[]uint8   H  "runtime.zerovalue   P  type.uint8   ş6go.typelink.[]uint8/[]uint8          type.[]uint8   ş~go.string."func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)" x  x    3   func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)   ~go.string."func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   ş~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int) ¨  ¨   g«¿ 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ~go.string."func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   @  go.weak.type.*func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   p˜ ~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   ˆ  "type."".PublicKey     type.[]uint8   ˜  $type.*math/big.Int      $type.*math/big.Int   ş¦go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"         G   func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)   ¦go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   şºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) ¸  ¸    “Rg 3                                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ¦go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   @  Ìgo.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   p¨ ºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ  "type."".PublicKey     $type.*math/big.Int   ˜  $type.*math/big.Int      type.[]uint8   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ş*go.string."PublicKey" (  $    	   PublicKey   *go.string."PublicKey"   şgo.string."Add"          Add   go.string."Add"   şšgo.string."func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ˜  ”    A   func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)   šgo.string."func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şÈtype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¸  ¸   ğ\áõ 3                                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  šgo.string."func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  Úgo.weak.type.*func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p¨ Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ş$go.string."Double"           Double   $go.string."Double"   şrgo.string."func(*big.Int, *big.Int) (*big.Int, *big.Int)" p  l    -   func(*big.Int, *big.Int) (*big.Int, *big.Int)   rgo.string."func(*big.Int, *big.Int) (*big.Int, *big.Int)"   şŒtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¨  ¨   3`1
 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  rgo.string."func(*big.Int, *big.Int) (*big.Int, *big.Int)"   @  go.weak.type.*func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p˜ Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ş*go.string."IsOnCurve" (  $    	   IsOnCurve   *go.string."IsOnCurve"   şRgo.string."func(*big.Int, *big.Int) bool" P  L       func(*big.Int, *big.Int) bool   Rgo.string."func(*big.Int, *big.Int) bool"   şXtype.func(*math/big.Int, *math/big.Int) bool        À§ 3                                                                °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  Rgo.string."func(*big.Int, *big.Int) bool"   @  jgo.weak.type.*func(*math/big.Int, *math/big.Int) bool   H  "runtime.zerovalue   Xˆ Xtype.func(*math/big.Int, *math/big.Int) bool   p˜ Xtype.func(*math/big.Int, *math/big.Int) bool   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  type.bool   ş$go.string."Params"           Params   $go.string."Params"   şPgo.string."func() *elliptic.CurveParams" P  J       func() *elliptic.CurveParams   Pgo.string."func() *elliptic.CurveParams"   şPtype.func() *crypto/elliptic.CurveParams      ˆ¨"å 3                                                          °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  Pgo.string."func() *elliptic.CurveParams"   @  bgo.weak.type.*func() *crypto/elliptic.CurveParams   H  "runtime.zerovalue   Xˆ Ptype.func() *crypto/elliptic.CurveParams   pˆ Ptype.func() *crypto/elliptic.CurveParams   ˆ  Btype.*crypto/elliptic.CurveParams   ş4go.string."ScalarBaseMult" 0  .       ScalarBaseMult   4go.string."ScalarBaseMult"   ş\go.string."func([]uint8) (*big.Int, *big.Int)" X  V    "   func([]uint8) (*big.Int, *big.Int)   \go.string."func([]uint8) (*big.Int, *big.Int)"   şbtype.func([]uint8) (*math/big.Int, *math/big.Int)        €Ÿ.l 3                                                                °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  \go.string."func([]uint8) (*big.Int, *big.Int)"   @  tgo.weak.type.*func([]uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ btype.func([]uint8) (*math/big.Int, *math/big.Int)   p btype.func([]uint8) (*math/big.Int, *math/big.Int)   ˆ  type.[]uint8     $type.*math/big.Int   ˜  $type.*math/big.Int   ş,go.string."ScalarMult" (  &    
   ScalarMult   ,go.string."ScalarMult"   ş„go.string."func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" €  ~    6   func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)   „go.string."func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ştype.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) °  °   ašÙÂ 3                                                                        °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  „go.string."func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   @  °go.weak.type.*func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   p  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  type.[]uint8      $type.*math/big.Int   ¨  $type.*math/big.Int   ş"type."".PublicKey  ¨  ¨   ™ÉZN                                                                                                                                                                                                                                                                   Z  ,type..alg."".PublicKey      Bruntime.gcbits.0x8c88000000000000   0  6go.string."ecdsa.PublicKey"   @  $type.*"".PublicKey   H  "runtime.zerovalue   Ph "type."".PublicKey   x  4type.crypto/elliptic.Curve     go.string."X"      $type.*math/big.Int   ¸  go.string."Y"   È  $type.*math/big.Int   8à "type."".PublicKey   à  *go.string."PublicKey"   è  "go.importpath."".   ğˆ "type."".PublicKey   ˆ  go.string."Add"   ˜  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)      ätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ¨  &"".(*PublicKey).Add   °   "".PublicKey.Add   ¸  $go.string."Double"   È  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   Ğ  ¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   Ø  ,"".(*PublicKey).Double   à  &"".PublicKey.Double   è  *go.string."IsOnCurve"   ø  Xtype.func(*math/big.Int, *math/big.Int) bool   €  ttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool   ˆ  2"".(*PublicKey).IsOnCurve     ,"".PublicKey.IsOnCurve   ˜  $go.string."Params"   ¨  Ptype.func() *crypto/elliptic.CurveParams   °  htype.func("".PublicKey) *crypto/elliptic.CurveParams   ¸  ,"".(*PublicKey).Params   À  &"".PublicKey.Params   È  4go.string."ScalarBaseMult"   Ø  btype.func([]uint8) (*math/big.Int, *math/big.Int)   à  ~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   è  <"".(*PublicKey).ScalarBaseMult   ğ  6"".PublicKey.ScalarBaseMult   ø  ,go.string."ScalarMult"   ˆ  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)     ºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˜  4"".(*PublicKey).ScalarMult      ."".PublicKey.ScalarMult   ş8go.string."*ecdsa.PublicKey" 8  2       *ecdsa.PublicKey   8go.string."*ecdsa.PublicKey"   ş¾go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ¸  ¸    S   func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)   ¾go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) À  À   ²% • 3                                                                                °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ¾go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  øgo.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p° ætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  $type.*"".PublicKey     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ¸  $type.*math/big.Int   ş–go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"       ?   func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)   –go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   şªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) °  °   ö&‡? 3                                                                        °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  –go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  ¼go.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p  ªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  $type.*"".PublicKey     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   şvgo.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) bool" p  p    /   func(*ecdsa.PublicKey, *big.Int, *big.Int) bool   vgo.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) bool"   şvtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool ¨  ¨   ›²N¢ 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  vgo.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) bool"   @  ˆgo.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   H  "runtime.zerovalue   Xˆ vtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   p  vtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   ˆ  $type.*"".PublicKey     $type.*math/big.Int   ˜  $type.*math/big.Int      type.bool   şpgo.string."func(*ecdsa.PublicKey) *elliptic.CurveParams" p  j    ,   func(*ecdsa.PublicKey) *elliptic.CurveParams   pgo.string."func(*ecdsa.PublicKey) *elliptic.CurveParams"   şjtype.func(*"".PublicKey) *crypto/elliptic.CurveParams ˜  ˜   Zmdš 3                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  pgo.string."func(*ecdsa.PublicKey) *elliptic.CurveParams"   @  |go.weak.type.*func(*"".PublicKey) *crypto/elliptic.CurveParams   H  "runtime.zerovalue   Xˆ jtype.func(*"".PublicKey) *crypto/elliptic.CurveParams   p jtype.func(*"".PublicKey) *crypto/elliptic.CurveParams   ˆ  $type.*"".PublicKey     Btype.*crypto/elliptic.CurveParams   ş€go.string."func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)" €  z    4   func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)   €go.string."func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   ş€type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int) ¨  ¨   3nÄ7 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  €go.string."func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   @  ’go.weak.type.*func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ €type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   p˜ €type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   ˆ  $type.*"".PublicKey     type.[]uint8   ˜  $type.*math/big.Int      $type.*math/big.Int   ş¨go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" ¨  ¢    H   func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)   ¨go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ş¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) ¸  ¸   fy< 3                                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ¨go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   @  Îgo.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   p¨ ¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ  $type.*"".PublicKey     $type.*math/big.Int   ˜  $type.*math/big.Int      type.[]uint8   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ş$type.*"".PublicKey         €Ğ/ 6                                                                                                                                                                                                  L@  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  8go.string."*ecdsa.PublicKey"   @  6go.weak.type.**"".PublicKey   H  "runtime.zerovalue   P  "type."".PublicKey   8X $type.*"".PublicKey   h€ $type.*"".PublicKey   €  go.string."Add"     Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˜  ætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)      &"".(*PublicKey).Add   ¨  &"".(*PublicKey).Add   °  $go.string."Double"   À  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   È  ªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   Ğ  ,"".(*PublicKey).Double   Ø  ,"".(*PublicKey).Double   à  *go.string."IsOnCurve"   ğ  Xtype.func(*math/big.Int, *math/big.Int) bool   ø  vtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   €  2"".(*PublicKey).IsOnCurve   ˆ  2"".(*PublicKey).IsOnCurve     $go.string."Params"      Ptype.func() *crypto/elliptic.CurveParams   ¨  jtype.func(*"".PublicKey) *crypto/elliptic.CurveParams   °  ,"".(*PublicKey).Params   ¸  ,"".(*PublicKey).Params   À  4go.string."ScalarBaseMult"   Ğ  btype.func([]uint8) (*math/big.Int, *math/big.Int)   Ø  €type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   à  <"".(*PublicKey).ScalarBaseMult   è  <"".(*PublicKey).ScalarBaseMult   ğ  ,go.string."ScalarMult"   €  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ  ¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)     4"".(*PublicKey).ScalarMult   ˜  4"".(*PublicKey).ScalarMult   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·2dc77d960dd3e4b3de2361f9cbd75783             şTgclocalsÂ·65526a5f07004f02424fe51b799cdd23               
    şTgclocalsÂ·fa7203fd5ed88aea99b7be572f707eb0                  ş8type..hashfunc."".PrivateKey          0type..hash."".PrivateKey   ş4type..eqfunc."".PrivateKey          ,type..eq."".PrivateKey   ş.type..alg."".PrivateKey              8type..hashfunc."".PrivateKey     4type..eqfunc."".PrivateKey   şBruntime.gcbits.0x8c88c88888000000   ŒˆÈˆˆ    ş8go.string."ecdsa.PrivateKey" 8  2       ecdsa.PrivateKey   8go.string."ecdsa.PrivateKey"   şgo.string."D"          D   go.string."D"   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·be52d99fd4fc187ec6a3cd1eab5661d9         ª   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·d0639bedff7ffedcd56695753d30706e         «ª  şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·6e5d4a330d25067342b1b461a5d19024      
   *    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·dd6da6b6c0a8ea1724ec8c8531209fd3         «*   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·8d11a518189555fd7f3bac3cc6ad264c         *    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·dafc2a4ed1eccf20e0ba3ca784d254a7         «*   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·06cab038d51064a089bda21fa03e00f7             şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·743023cec9b4b515d11a8fbfd57d92fa         «   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·9f0d5ba6770c4a1ed4fa771547e96df1         
    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·fb6dce094c1dd234d359f74ad2ce663f         «
   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·6f36ab01c3b1e9831d2d7a8e3c4180c2         ª    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·820c449159202a11cc0e8f118b89b1ba         «ª   ş¾go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ¸  ¸    S   func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)   ¾go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) À  À   ü¼IÍ 3                                                                                °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ¾go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  øgo.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p° ætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  $type."".PrivateKey     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ¸  $type.*math/big.Int   ş–go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"       ?   func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)   –go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   şªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) °  °   Œÿ‰x 3                                                                        °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  –go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  ¼go.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p  ªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  $type."".PrivateKey     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   şvgo.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) bool" p  p    /   func(ecdsa.PrivateKey, *big.Int, *big.Int) bool   vgo.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) bool"   şvtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool ¨  ¨   "‚ù 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  vgo.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) bool"   @  ˆgo.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int) bool   H  "runtime.zerovalue   Xˆ vtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   p  vtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   ˆ  $type."".PrivateKey     $type.*math/big.Int   ˜  $type.*math/big.Int      type.bool   şpgo.string."func(ecdsa.PrivateKey) *elliptic.CurveParams" p  j    ,   func(ecdsa.PrivateKey) *elliptic.CurveParams   pgo.string."func(ecdsa.PrivateKey) *elliptic.CurveParams"   şjtype.func("".PrivateKey) *crypto/elliptic.CurveParams ˜  ˜   Ó'î 3                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  pgo.string."func(ecdsa.PrivateKey) *elliptic.CurveParams"   @  |go.weak.type.*func("".PrivateKey) *crypto/elliptic.CurveParams   H  "runtime.zerovalue   Xˆ jtype.func("".PrivateKey) *crypto/elliptic.CurveParams   p jtype.func("".PrivateKey) *crypto/elliptic.CurveParams   ˆ  $type."".PrivateKey     Btype.*crypto/elliptic.CurveParams   ş€go.string."func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)" €  z    4   func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)   €go.string."func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   ş€type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int) ¨  ¨   |Œ¤» 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  €go.string."func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   @  ’go.weak.type.*func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ €type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   p˜ €type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   ˆ  $type."".PrivateKey     type.[]uint8   ˜  $type.*math/big.Int      $type.*math/big.Int   ş¨go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" ¨  ¢    H   func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)   ¨go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ş¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) ¸  ¸   ¥ÑX 3                                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ¨go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   @  Îgo.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   p¨ ¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ  $type."".PrivateKey     $type.*math/big.Int   ˜  $type.*math/big.Int      type.[]uint8   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ş,go.string."PrivateKey" (  &    
   PrivateKey   ,go.string."PrivateKey"   ş$type."".PrivateKey  €  €   A;!–                                                                                                                                                                                                                                                V  .type..alg."".PrivateKey      Bruntime.gcbits.0x8c88c88888000000   0  8go.string."ecdsa.PrivateKey"   @  &type.*"".PrivateKey   H  "runtime.zerovalue   Ph $type."".PrivateKey   x  "type."".PublicKey     go.string."D"      $type.*math/big.Int   8¸ $type."".PrivateKey   ¸  ,go.string."PrivateKey"   À  "go.importpath."".   Èà $type."".PrivateKey   à  go.string."Add"   ğ  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ø  ætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €  ("".(*PrivateKey).Add   ˆ  """.PrivateKey.Add     $go.string."Double"      Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ¨  ªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   °  ."".(*PrivateKey).Double   ¸  ("".PrivateKey.Double   À  *go.string."IsOnCurve"   Ğ  Xtype.func(*math/big.Int, *math/big.Int) bool   Ø  vtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   à  4"".(*PrivateKey).IsOnCurve   è  ."".PrivateKey.IsOnCurve   ğ  $go.string."Params"   €  Ptype.func() *crypto/elliptic.CurveParams   ˆ  jtype.func("".PrivateKey) *crypto/elliptic.CurveParams     ."".(*PrivateKey).Params   ˜  ("".PrivateKey.Params      4go.string."ScalarBaseMult"   °  btype.func([]uint8) (*math/big.Int, *math/big.Int)   ¸  €type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   À  >"".(*PrivateKey).ScalarBaseMult   È  8"".PrivateKey.ScalarBaseMult   Ğ  ,go.string."ScalarMult"   à  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   è  ¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ğ  6"".(*PrivateKey).ScalarMult   ø  0"".PrivateKey.ScalarMult   ş:go.string."*ecdsa.PrivateKey" 8  4       *ecdsa.PrivateKey   :go.string."*ecdsa.PrivateKey"   şÀgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" À  º    T   func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)   Àgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) À  À   w©Kı 3                                                                                °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  Àgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  úgo.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p° ètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  &type.*"".PrivateKey     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ¸  $type.*math/big.Int   ş˜go.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)" ˜  ’    @   func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)   ˜go.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   ş¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) °  °   ;šN 3                                                                        °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ˜go.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  ¾go.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p  ¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  &type.*"".PrivateKey     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   şxgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool" x  r    0   func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool   xgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool"   şxtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool ¨  ¨   ^IŒ? 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  xgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool"   @  Šgo.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   H  "runtime.zerovalue   Xˆ xtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   p  xtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   ˆ  &type.*"".PrivateKey     $type.*math/big.Int   ˜  $type.*math/big.Int      type.bool   şrgo.string."func(*ecdsa.PrivateKey) *elliptic.CurveParams" p  l    -   func(*ecdsa.PrivateKey) *elliptic.CurveParams   rgo.string."func(*ecdsa.PrivateKey) *elliptic.CurveParams"   şltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams ˜  ˜   “â 3                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  rgo.string."func(*ecdsa.PrivateKey) *elliptic.CurveParams"   @  ~go.weak.type.*func(*"".PrivateKey) *crypto/elliptic.CurveParams   H  "runtime.zerovalue   Xˆ ltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams   p ltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams   ˆ  &type.*"".PrivateKey     Btype.*crypto/elliptic.CurveParams   şhgo.string."func(*ecdsa.PrivateKey) crypto.PublicKey" h  b    (   func(*ecdsa.PrivateKey) crypto.PublicKey   hgo.string."func(*ecdsa.PrivateKey) crypto.PublicKey"   şTtype.func(*"".PrivateKey) crypto.PublicKey ˜  ˜   5­EK 3                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  hgo.string."func(*ecdsa.PrivateKey) crypto.PublicKey"   @  fgo.weak.type.*func(*"".PrivateKey) crypto.PublicKey   H  "runtime.zerovalue   Xˆ Ttype.func(*"".PrivateKey) crypto.PublicKey   p Ttype.func(*"".PrivateKey) crypto.PublicKey   ˆ  &type.*"".PrivateKey     *type.crypto.PublicKey   ş‚go.string."func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)" €  |    5   func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)   ‚go.string."func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   ş‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int) ¨  ¨   ßÒ 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ‚go.string."func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   @  ”go.weak.type.*func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   p˜ ‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   ˆ  &type.*"".PrivateKey     type.[]uint8   ˜  $type.*math/big.Int      $type.*math/big.Int   şªgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" ¨  ¤    I   func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)   ªgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ş¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) ¸  ¸   ò	 3                                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ªgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   @  Ğgo.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   p¨ ¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ  &type.*"".PrivateKey     $type.*math/big.Int   ˜  $type.*math/big.Int      type.[]uint8   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ş¶go.string."func(*ecdsa.PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)" °  °    O   func(*ecdsa.PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   ¶go.string."func(*ecdsa.PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)"   ş¢type.func(*"".PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error) ¸  ¸   ¥"Ó 3                                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ¶go.string."func(*ecdsa.PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)"   @  ´go.weak.type.*func(*"".PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   H  "runtime.zerovalue   Xˆ ¢type.func(*"".PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   p¨ ¢type.func(*"".PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   ˆ  &type.*"".PrivateKey     type.io.Reader   ˜  type.[]uint8      ,type.crypto.SignerOpts   ¨  type.[]uint8   °  type.error   ş$go.string."Public"           Public   $go.string."Public"   şFgo.string."func() crypto.PublicKey" @  @       func() crypto.PublicKey   Fgo.string."func() crypto.PublicKey"   ş8type.func() crypto.PublicKey      T¿, 3                                                          °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  Fgo.string."func() crypto.PublicKey"   @  Jgo.weak.type.*func() crypto.PublicKey   H  "runtime.zerovalue   Xˆ 8type.func() crypto.PublicKey   pˆ 8type.func() crypto.PublicKey   ˆ  *type.crypto.PublicKey   ş go.string."Sign"           Sign    go.string."Sign"   şgo.string."func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)"   Š    <   func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   go.string."func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)"   ş‚type.func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error) °  °   —@` 3                                                                        °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  go.string."func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)"   @  ”go.weak.type.*func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   H  "runtime.zerovalue   Xˆ ‚type.func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   p  ‚type.func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   ˆ  type.io.Reader     type.[]uint8   ˜  ,type.crypto.SignerOpts      type.[]uint8   ¨  type.error   ş&type.*"".PrivateKey  €  €   Ñƒ¿Ê 6                                                                                                                                                                                                                                                  `@  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  :go.string."*ecdsa.PrivateKey"   @  8go.weak.type.**"".PrivateKey   H  "runtime.zerovalue   P  $type."".PrivateKey   8X &type.*"".PrivateKey   h€ &type.*"".PrivateKey   €  go.string."Add"     Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˜  ètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)      ("".(*PrivateKey).Add   ¨  ("".(*PrivateKey).Add   °  $go.string."Double"   À  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   È  ¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   Ğ  ."".(*PrivateKey).Double   Ø  ."".(*PrivateKey).Double   à  *go.string."IsOnCurve"   ğ  Xtype.func(*math/big.Int, *math/big.Int) bool   ø  xtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   €  4"".(*PrivateKey).IsOnCurve   ˆ  4"".(*PrivateKey).IsOnCurve     $go.string."Params"      Ptype.func() *crypto/elliptic.CurveParams   ¨  ltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams   °  ."".(*PrivateKey).Params   ¸  ."".(*PrivateKey).Params   À  $go.string."Public"   Ğ  8type.func() crypto.PublicKey   Ø  Ttype.func(*"".PrivateKey) crypto.PublicKey   à  ."".(*PrivateKey).Public   è  ."".(*PrivateKey).Public   ğ  4go.string."ScalarBaseMult"   €  btype.func([]uint8) (*math/big.Int, *math/big.Int)   ˆ  ‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)     >"".(*PrivateKey).ScalarBaseMult   ˜  >"".(*PrivateKey).ScalarBaseMult      ,go.string."ScalarMult"   °  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ¸  ¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   À  6"".(*PrivateKey).ScalarMult   È  6"".(*PrivateKey).ScalarMult   Ğ   go.string."Sign"   à  ‚type.func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   è  ¢type.func(*"".PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   ğ  *"".(*PrivateKey).Sign   ø  *"".(*PrivateKey).Sign   şBgo.string."*ecdsa.ecdsaSignature" @  <       *ecdsa.ecdsaSignature   Bgo.string."*ecdsa.ecdsaSignature"   ş.type.*"".ecdsaSignature  X  X   ©
ÛK 6                                @  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  Bgo.string."*ecdsa.ecdsaSignature"   @  @go.weak.type.**"".ecdsaSignature   H  "runtime.zerovalue   P  ,type."".ecdsaSignature   ş@go.string."ecdsa.ecdsaSignature" @  :       ecdsa.ecdsaSignature   @go.string."ecdsa.ecdsaSignature"   şgo.string."R"          R   go.string."R"   şgo.string."S"          S   go.string."S"   ş4go.string."ecdsaSignature" 0  .       ecdsaSignature   4go.string."ecdsaSignature"   ş,type."".ecdsaSignature  à  à   DÁ)e                                                                                                  P  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  @go.string."ecdsa.ecdsaSignature"   @  .type.*"".ecdsaSignature   H  "runtime.zerovalue   Ph ,type."".ecdsaSignature   h  go.string."R"   x  $type.*math/big.Int     go.string."S"      $type.*math/big.Int   8¸ ,type."".ecdsaSignature   ¸  4go.string."ecdsaSignature"   À  "go.importpath."".   Èà ,type."".ecdsaSignature   ş$go.string."crypto"           crypto   $go.string."crypto"   ş*go.importpath.crypto.            $go.string."crypto"   ş&go.string."runtime"            runtime   &go.string."runtime"   ş,go.importpath.runtime.            &go.string."runtime"   şgo.string."io"          io   go.string."io"   ş"go.importpath.io.            go.string."io"   ş6go.string."crypto/elliptic" 0  0       crypto/elliptic   6go.string."crypto/elliptic"   ş<go.importpath.crypto/elliptic.            6go.string."crypto/elliptic"   ş2go.string."encoding/asn1" 0  ,       encoding/asn1   2go.string."encoding/asn1"   ş8go.importpath.encoding/asn1.            2go.string."encoding/asn1"   ş(go.string."math/big" (  "       math/big   (go.string."math/big"   ş.go.importpath.math/big.            (go.string."math/big"   ş4type..hash."".PublicKeyÂ·f          .type..hash."".PublicKey   ş(runtime.interhashÂ·f          "runtime.interhash   ş$runtime.memhashÂ·f          runtime.memhash   ş0type..eq."".PublicKeyÂ·f          *type..eq."".PublicKey   ş$runtime.ifaceeqÂ·f          runtime.ifaceeq   ş,"".(*PublicKey).AddÂ·f          &"".(*PublicKey).Add   ş&"".PublicKey.AddÂ·f           "".PublicKey.Add   ş2"".(*PublicKey).DoubleÂ·f          ,"".(*PublicKey).Double   ş,"".PublicKey.DoubleÂ·f          &"".PublicKey.Double   ş8"".(*PublicKey).IsOnCurveÂ·f          2"".(*PublicKey).IsOnCurve   ş2"".PublicKey.IsOnCurveÂ·f          ,"".PublicKey.IsOnCurve   ş2"".(*PublicKey).ParamsÂ·f          ,"".(*PublicKey).Params   ş,"".PublicKey.ParamsÂ·f          &"".PublicKey.Params   şB"".(*PublicKey).ScalarBaseMultÂ·f          <"".(*PublicKey).ScalarBaseMult   ş<"".PublicKey.ScalarBaseMultÂ·f          6"".PublicKey.ScalarBaseMult   ş:"".(*PublicKey).ScalarMultÂ·f          4"".(*PublicKey).ScalarMult   ş4"".PublicKey.ScalarMultÂ·f          ."".PublicKey.ScalarMult   ş6type..hash."".PrivateKeyÂ·f          0type..hash."".PrivateKey   ş2type..eq."".PrivateKeyÂ·f          ,type..eq."".PrivateKey   ş."".(*PrivateKey).AddÂ·f          ("".(*PrivateKey).Add   ş("".PrivateKey.AddÂ·f          """.PrivateKey.Add   ş4"".(*PrivateKey).DoubleÂ·f          ."".(*PrivateKey).Double   ş."".PrivateKey.DoubleÂ·f          ("".PrivateKey.Double   ş:"".(*PrivateKey).IsOnCurveÂ·f          4"".(*PrivateKey).IsOnCurve   ş4"".PrivateKey.IsOnCurveÂ·f          ."".PrivateKey.IsOnCurve   ş4"".(*PrivateKey).ParamsÂ·f          ."".(*PrivateKey).Params   ş."".PrivateKey.ParamsÂ·f          ("".PrivateKey.Params   şD"".(*PrivateKey).ScalarBaseMultÂ·f          >"".(*PrivateKey).ScalarBaseMult   ş>"".PrivateKey.ScalarBaseMultÂ·f          8"".PrivateKey.ScalarBaseMult   ş<"".(*PrivateKey).ScalarMultÂ·f          6"".(*PrivateKey).ScalarMult   ş6"".PrivateKey.ScalarMultÂ·f          0"".PrivateKey.ScalarMult   ş"runtime.zerovalue      ÿÿgo13ld